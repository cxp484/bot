#!/bin/bash
CURRENT_DIR=`pwd`
SCRIPTDIR=`dirname "$(readlink -f "$0")"`
cd $SCRIPTDIR/../../..
FIREMODELS_ROOT=`pwd`
export FIREMODELS_ROOT
cd $CURRENT_DIR

ALL_HOSTS="$CB_HOSTS $CB_LOGIN $CB_HEAD"

#---------------------------------------------
#                   MKDIR
#---------------------------------------------

MKDIR ()
{
 local dir=$1

 if [ ! -d $dir ]; then
   mkdir -p $dir
 fi
 if [ ! -d $dir ]; then
   error "***error: failed to create the directory $dir"
   return 0
 fi
 return 1
}

#---------------------------------------------
#                   MAKE_DATA_DIRS
#---------------------------------------------

MAKE_DATA_DIRS()
{
  tempfile=$SCRIPTDIR/temp.$$
  touch $tempfile
  ERROR=
  if [ -e $tempfile ]; then
    rm $tempfile
    CB_DATA_DIR=$SCRIPTDIR
  else
    CB_DATA_DIR=$HOME/.clusterbot
    MKDIR $CB_DATA_DIR
  fi
  OUTPUT_DIR=$CB_DATA_DIR/output
  FDSOUTPUT_DIR=$CB_DATA_DIR/fdsoutput
  FILES_DIR=$CB_DATA_DIR/files
  MKDIR $OUTPUT_DIR
  if [ $? -eq 0 ]; then
    ERROR=1
  fi
  MKDIR $FDSOUTPUT_DIR
  if [ $? -eq 0 ]; then
    ERROR=1
  fi
  MKDIR $FILES_DIR
  if [ $? -eq 0 ]; then
    ERROR=1
  fi
  if [ "$ERROR" == "1" ]; then
    return 1
  fi
  rm -f $OUTPUT_DIR/*
  rm -f $FILES_DIR/*
  rm -f $FDSOUTPUT_DIR/*
  return 0
}

#---------------------------------------------
#                   SETUP_CLCK
#---------------------------------------------

SETUP_CLCK()
{
  out=/tmp/program.out.$$
  clck -v >& $out
  notfound=`cat $out | tail -1 | grep "not found" | wc -l`
  rm $out
  if [ "$notfound" == "1" ] ; then
    echo "***warning: cluster checker, clck, not installed or not in path"
  else
    CHECK_CLUSTER=`which clck`
  fi
  return 0
}

#---------------------------------------------
#                   CHECK_DIR_LIST
#---------------------------------------------

CHECK_DIR_LIST()
{
  local basedir=$1
  local rootdir=$2

  currentdirlist=/tmp/dirlist.$$
  ls -l $basedir/$rootdir | sort | sed '1 d' > $currentdirlist
  
  if [ ! -e $ARCHIVEDIR/$rootdir ]; then
    cp $currentdirlist $ARCHIVEDIR/$rootdir
  fi
  
  ndiffs=`diff $ARCHIVEDIR/$rootdir $currentdirlist | wc -l`
 
  dirdate=`ls -l $ARCHIVEDIR/$rootdir | awk '{print $6" "$7" "$8}'`
  if [ $ndiffs -eq 0 ]; then
    echo "   `hostname -s`: The directory $basedir/$rootdir has not changed since $dirdate"
  else
    echo "   `hostname -s`: The directory $basedir/$rootdir has changed since $dirdate"
    if [ "$UPDATE_ARCHIVE" == "1" ]; then
      cp $currentdirlist $ARCHIVEDIR/$rootdir
    fi
  fi
  rm $currentdirlist
}

#---------------------------------------------
#                   CHECK_SSHD_CONFIG
#---------------------------------------------

CHECK_SSHD_CONFIG ()
{
  local file=sshdT_config
  local filesave=${file}.save
  local fullfile=/tmp/${file}.$$
  
  if [ "$USE_SUDO" == "" ]; then
    echo "*** sudo command required to perform this check"
    USE_SUDO=1
  fi
  sudo sshd -T | sort >  $fullfile
  if [ ! -e $ARCHIVEDIR/$filesave ]; then
    cp $fullfile $ARCHIVEDIR/$filesave
  fi

  diffs=`diff $ARCHIVEDIR/$filesave $fullfile | wc -l`
  dirdate=`ls -l $ARCHIVEDIR/$filesave | awk '{print $6" "$7" "$8}'`
 
  if [ $diffs -eq 0 ]; then
    echo "   `hostname -s`: sshd configuration parameters, generated by sshd -T, have not changed since they were archived at $ARCHIVEDIR/$filesave on $dirdate"
  else
    echo "   `hostname -s`: ***warning: sshd configuration parameters, generated by sshd -T, have changed since they were archived at $ARCHIVEDIR/$filesave on $dirdate"
    if [ "$UPDATE_ARCHIVE" == "1" ]; then
      cp $fullfile $ARCHIVEDIR/$filesave
    fi
  fi
  rm $fullfile
}

#---------------------------------------------
#                   CHECK_FILE_DATE
#---------------------------------------------

CHECK_FILE_DATE()
{
  local fullfile=$1
  local file=`basename $fullfile`
  local filels=${file}.ls

  if [ ! -e $fullfile ]; then
    echo "***error: $fullfile does not exist"
    return
  fi
  currentfilelist=/tmp/dirlist.$$
  ls -l $fullfile  > $currentfilelist
  
  if [ ! -e $ARCHIVEDIR/$filels ]; then
    cp $currentfilelist $ARCHIVEDIR/$filels
  fi
  
  diffs=`diff $ARCHIVEDIR/$filels $currentfilelist | wc -l`
 
  original_moddate=`cat $ARCHIVEDIR/$filels | awk '{print $6" "$7" "$8}'`
  original_filesize=`cat $ARCHIVEDIR/$filels | awk '{print $5}'`
  current_moddate=`cat $currentfilelist | awk '{print $6" "$7" "$8}'`
  current_filesize=`cat $currentfilelist | awk '{print $5}'`
  if [ $diffs -eq 0 ]; then
    echo "   `hostname -s`: The file $fullfile has not changed since $current_moddate(file size: $current_filesize)"
  else
    echo "   `hostname -s`: ***warning: $fullfile has changed - current($current_moddate), original($original_moddate) modification date,"
    echo "                  current($current_filesize), original($original_filesize) file size."
    if [ "$UPDATE_ARCHIVE" == "1" ]; then
      cp $currentfilelist $ARCHIVEDIR/$filels
    fi
  fi
  rm $currentfilelist
}

#---------------------------------------------
#                   CHECK_DAEMON
#---------------------------------------------

CHECK_DAEMON ()
{
 local DAEMON_ARG=$1
 local ERRWARN=$2
 local CB_HOST_ARG=$3

DAEMONOUT=$FILES_DIR/daemon.out.$$
DAEMONOUT2=$FILES_DIR/daemon2.out.$$

pdsh -t 1 -w "$CB_HOST_ARG" "ps -el | grep $DAEMON_ARG | wc -l" >&  $DAEMONOUT2
cat $DAEMONOUT2 | grep -v ssh | grep -v Connection | sort >& $DAEMONOUT
DAEMONDOWN=
while read line 
do
  host=`echo $line | awk '{print $1}'`
  host=`echo $host | sed 's/.$//'`
  NDAEMON=`echo $line | awk '{print $2}'`
  if [ $NDAEMON -eq 0 ]; then
    DAEMONDOWN="$DAEMONDOWN $host"
  fi
done < $DAEMONOUT

if [ "$DAEMONDOWN" == "" ]; then
  echo "   $CB_HOST_ARG: $DAEMON_ARG running"
else
  echo "   $CB_HOST_ARG: ***$ERRWARN: $DAEMON_ARG down on $DAEMONDOWN"
  echo "      Fix: sudo pdsh -t 1 -w $CB_HOST_ARG service $DAEMON_ARG start"
fi
rm -f $DAEMONOUT $DAEMONOUT2
}

#---------------------------------------------
#                   ACCT_CHECK
#---------------------------------------------

ACCT_CHECK ()
{
  local file=$1
  local outdir=$2

  local CB_HOST_ARG=$3

  if [ "$CB_HOST_ARG" == "" ]; then
    return 0
  fi
  FILE_OUT=$outdir/acct_check.out
  FILE_OUT2=$outdir/acct_check2.out
  pdsh -t 1 -w "$CB_HOST_ARG" `pwd`/getfile.sh $file $outdir >& $FILE_OUT2
  cat $FILE_OUT2 | grep -v ssh | grep -v Connection | sort >& $FILE_OUT
  file0=`head -1 $FILE_OUT | awk '{print $2}'`

  local CURDIR=`pwd`
  cd $outdir
 
  FILEDIFF=
  while read line 
  do
    hosti=`echo $line | awk '{print $1}' | awk -F':' '{print $1}'`
    filei=`echo $line | awk '{print $2}'`
    ndiff=`diff $file0 $filei | wc -l`
    if [ $ndiff -ne 0 ]; then
      if [ "$FILEDIFF" == "" ]; then
        FILEDIFF="$hosti"
      else
        FILEDIFF="$FILEDIFF $hosti"
      fi
    fi
  done < $FILE_OUT
  cd $CURDIR

  if [ "$FILEDIFF" == "" ]; then
    echo "   $CB_HOST_ARG: $file identical"
    return 0
  else
    echo "   $CB_HOST_ARG: ***error: $file is different on $FILEDIFF "
    return 1
  fi
}

#---------------------------------------------
#                   CHECK_FILE
#---------------------------------------------

CHECK_FILE ()
{
  local file=$1
  local ERRWARN=$2
  local INDENT=$3
  local outdir=$4
  local CB_HOST_ARG=$5

  if [ "$CB_HOST_ARG" == "" ]; then
    return 0
  fi
  FILE_OUT=$outdir/check_file.out
  FILE_OUT2=$outdir/check_file.out2
  pdsh -t 1 -w "$CB_HOST_ARG" `pwd`/getfile.sh $file $outdir >& $FILE_OUT2
  cat $FILE_OUT2 | grep -v ssh | grep -v Connection | sort >& $FILE_OUT
  file0=`head -1 $FILE_OUT | awk '{print $2}'`

  local CURDIR=`pwd`
  cd $outdir
 
  FILEDIFF=
  while read line 
  do
    hosti=`echo $line | awk '{print $1}' | awk -F':' '{print $1}'`
    filei=`echo $line | awk '{print $2}'`
    ndiff=`diff $file0 $filei | wc -l`
    if [ $ndiff -ne 0 ]; then
      if [ "$FILEDIFF" == "" ]; then
        FILEDIFF="$hosti"
      else
        FILEDIFF="$FILEDIFF $hosti"
      fi
    fi
  done < $FILE_OUT
  cd $CURDIR

  if [ "$FILEDIFF" == "" ]; then
    if [ "$INDENT" == "1" ]; then
      echo "   $CB_HOST_ARG:    $file identical"
    else
      echo "   $CB_HOST_ARG: $file identical"
    fi
    return 0
  else
    if [ "$INDENT" == "1" ]; then
      echo "   $CB_HOST_ARG:    ***$ERRWARN: $file is different on $FILEDIFF "
    else
      echo "   $CB_HOST_ARG: ***$ERRWARN: $file is different on $FILEDIFF "
    fi
    return 1
  fi
}

#---------------------------------------------
#                   TIME_CHECK
#---------------------------------------------

TIME_CHECK ()
{
  local INDENT=$1
  local TOLERANCE=$2
  local outdir=$3
  local CB_HOST_ARG=$4

  if [ "$CB_HOST_ARG" == "" ]; then
    return 0
  fi
  FILE_OUT=$outdir/time_check.out
  FILE_OUT2=$outdir/time_check.out2
  pdsh -t 1 -w "$CB_HOST_ARG" `pwd`/gettime_error.sh >& $FILE_OUT2
  cat $FILE_OUT2 | grep -v ssh | grep -v Connection | sort >& $FILE_OUT

  local CURDIR=`pwd`
  cd $outdir
 
  MAX_ERROR=`head -1 $FILE_OUT | awk '{print $2}'`
  TIMEERROR_LIST=
  while read line 
  do
    hosti=`echo $line | awk '{print $1}' | awk -F':' '{print $1}'`
    timei=`echo $line | awk '{print $2}'`
    IS_BIGGER=`echo "$timei > $MAX_ERROR" | bc -l`
    if [ "$IS_BIGGER" == "1" ]; then
      MAX_ERROR=$timei
    fi
    TOBIG=`echo "$timei > $TOLERANCE" | bc -l`
    if [ "$TOBIG" == "1" ]; then
      if [ "$TIMEROR_LIST" == "" ]; then
        TIMEERROR_LIST="$hosti/$timei"
      else
        TIMEERROR_LIST="$TIMEERROR_LIST $hosti/$timei"
      fi
    fi
  done < $FILE_OUT
  cd $CURDIR

  if [ "$TIMEERROR_LIST" == "" ]; then
    if [ "$INDENT" == "1" ]; then
      echo "   $CB_HOST_ARG:    max clock error = $MAX_ERROR s < $TOLERANCE s"
    else
      echo "   $CB_HOST_ARG: max clock error = $MAX_ERROR s < $TOLERANCE s"
    fi
    return 0
  else
    if [ "$INDENT" == "1" ]; then
      echo "   $CB_HOST_ARG:    ***error: clock error > $TOLERANCE s on $TIMEERROR_LIST"
    else
      echo "   $CB_HOST_ARG: ***error: clock error > $TOLERANCE s on $TIMEERROR_LIST"
    fi
    return 1
  fi
}

#---------------------------------------------
#                   MOUNT_CHECK
#---------------------------------------------

MOUNT_CHECK ()
{
  local INDENT=$1
  local outdir=$2
  local CB_HOST_ARG=$3

  file="NFS mounts"

  if [ "$CB_HOST_ARG" == "" ]; then
    return 0
  fi
  FILE_OUT=$outdir/mount_check.out
  FILE_OUT2=$outdir/mount_check.out2
  pdsh -t 1 -w $CB_HOST_ARG `pwd`/getmounts.sh $outdir >& $FILE_OUT2
  cat $FILE_OUT2 | grep -v ssh | grep -v Connection | sort >& $FILE_OUT
  file0=`head -1 $FILE_OUT | awk '{print $2}'`

  local CURDIR=`pwd`
  cd $outdir
 
  FILEDIFF=
  while read line 
  do
    hosti=`echo $line | awk '{print $1}' | awk -F':' '{print $1}'`
    filei=`echo $line | awk '{print $2}'`
    ndiff=`diff $file0 $filei | wc -l`
    if [ $ndiff -ne 0 ]; then
      if [ "$FILEDIFF" == "" ]; then
        FILEDIFF="$hosti"
      else
        FILEDIFF="$FILEDIFF $hosti"
      fi
    fi
  done < $FILE_OUT
  cd $CURDIR

  if [ "$FILEDIFF" == "" ]; then
    if [ "$INDENT" == "1" ]; then
       echo "   $CB_HOST_ARG:    $file identical"
    else
       echo "   $CB_HOST_ARG: $file identical"
    fi
    return 0
  else
    if [ "$INDENT" == "1" ]; then
       echo "   $CB_HOST_ARG:    ***error: $file are different on $FILEDIFF "
    else
       echo "   $CB_HOST_ARG: ***error: $file are different on $FILEDIFF "
    fi
    return 1
  fi
}

#---------------------------------------------
#                   FSTAB_CHECK
#---------------------------------------------

FSTAB_CHECK ()
{
  local outdir=$1
  local INDENT=$2
  local CB_HOST_ARG=$3

  file=/etc/fstab

  if [ "$CB_HOST_ARG" == "" ]; then
    return 0
  fi
  FILE_OUT=$outdir/fstab_check.out
  FILE_OUT2=$outdir/fstab_check.out2
  pdsh -t 1 -w $CB_HOST_ARG `pwd`/getfstab.sh $outdir >& $FILE_OUT2
  cat $FILE_OUT2 | grep -v ssh | grep -v Connection | sort >& $FILE_OUT
  file0=`head -1 $FILE_OUT | awk '{print $2}'`

  local CURDIR=`pwd`
  cd $outdir
 
  FILEDIFF=
  while read line 
  do
    hosti=`echo $line | awk '{print $1}' | awk -F':' '{print $1}'`
    filei=`echo $line | awk '{print $2}'`
    ndiff=`diff -w $file0 $filei | wc -l`
    if [ $ndiff -ne 0 ]; then
      if [ "$FILEDIFF" == "" ]; then
        FILEDIFF="$hosti"
      else
        FILEDIFF="$FILEDIFF $hosti"
      fi
    fi
  done < $FILE_OUT
  cd $CURDIR

  if [ "$FILEDIFF" == "" ]; then
    if [ "$INDENT" == "1" ]; then
      echo "   $CB_HOST_ARG:    $file identical"
    else
      echo "   $CB_HOST_ARG: $file identical"
    fi
    return 0
  else
    if [ "$INDENT" == "1" ]; then
       echo "   $CB_HOST_ARG:    ***error: $file is different on $FILEDIFF "
    else
       echo "   $CB_HOST_ARG: ***error: $file is different on $FILEDIFF "
    fi
    return 1
  fi
}

#---------------------------------------------
#                   HOST_CHECK
#---------------------------------------------

HOST_CHECK ()
{
  local outdir=$1
  INDENT=$2
  local CB_HOST_ARG=$3

  file=/etc/hosts

  if [ "$CB_HOST_ARG" == "" ]; then
    return 0
  fi
  FILE_OUT=$outdir/host_check.out
  FILE_OUT2=$outdir/host_check.out2
  pdsh -t 1 -w "$CB_HOST_ARG" `pwd`/gethost.sh $outdir >& $FILE_OUT2
  cat $FILE_OUT2 | grep -v ssh | grep -v Connection | sort >& $FILE_OUT
  file0=`head -1 $FILE_OUT | awk '{print $2}'`

  local CURDIR=`pwd`
  cd $outdir
 
  FILEDIFF=
  while read line 
  do
    hosti=`echo $line | awk '{print $1}' | awk -F':' '{print $1}'`
    filei=`echo $line | awk '{print $2}'`
    ndiff=`diff $file0 $filei | wc -l`
    if [ $ndiff -ne 0 ]; then
      if [ "$FILEDIFF" == "" ]; then
        FILEDIFF="$hosti"
      else
        FILEDIFF="$FILEDIFF $hosti"
      fi
    fi
  done < $FILE_OUT
  cd $CURDIR

  if [ "$FILEDIFF" == "" ]; then
    if [  "$INDENT" == "1" ]; then
       echo "   $CB_HOST_ARG:    $file identical"
    else
       echo "   $CB_HOST_ARG: $file identical"
    fi
    return 0
  else
    if [ "$INDENT" == "1" ]; then
       echo "   $CB_HOST_ARG:    ***error: $file is different on $FILEDIFF "
    else
       echo "   $CB_HOST_ARG: ***error: $file is different on $FILEDIFF "
    fi
    return 1
  fi
}

#---------------------------------------------
#                   RPM_CHECK
#---------------------------------------------

RPM_CHECK ()
{
 local INDENT=$1
 local prefix=$2
 local CB_HOST_ARG=$3

if [ "$CB_HOST_ARG" == "" ]; then
  return 0
fi
rm -f $FILES_DIR/${prefix}rpm*.txt
pdsh -t 1 -w "$CB_HOST_ARG" `pwd`/getrpms.sh $FILES_DIR $prefix >& $SLURMRPM_OUT

local CURDIR=`pwd`
cd $FILES_DIR
rpm0=`ls -l ${prefix}rpm*.txt | head -1 | awk '{print $9}'`
host0=`echo $rpm0 | sed 's/.txt$//'`
host0=`echo $host0 | sed 's/^.*rpm_//'`
RPMDIFF=
for f in ${prefix}rpm*.txt
do
  ndiff=`diff $rpm0 $f | wc -l`
  if [ $ndiff -ne 0 ]; then
    hostdiff=`echo $f | sed 's/.txt$//'`
    hostdiff=`echo $hostdiff | sed 's/^.*rpm_//'`
    if [ "$RPMDIFF" == "" ]; then
      RPMDIFF="$hostdiff"
    else
      RPMDIFF="$RPMDIFF $hostdiff"
    fi
  fi
done
cd $CURDIR

if [ "$RPMDIFF" == "" ]; then
  if [ "$INDENT" == "1" ]; then
     echo "   $CB_HOST_ARG:    rpms identical"
  else
     echo "   $CB_HOST_ARG: rpms identical"
  fi
  return 0
else
  if [ "$INDENT" == "1" ]; then
     echo "   $CB_HOST_ARG:    ***error: $host0 rpms are different from those on $RPMDIFF "
     echo "         Fix: reimage host or install updated rpm packages"
  else
     echo "   $CB_HOST_ARG: ***error: $host0 rpms are different from those on $RPMDIFF "
     echo "      Fix: reimage host or install updated rpm packages"
  fi
  return 1
fi
}

#---------------------------------------------
#                   OPENSM_CHECK
#---------------------------------------------

OPENSM_CHECK ()
{
  local CB_HOST_ARG=$1
  local CB_HOSTIB_ARG=$2

  if [ "$CB_HOSTIB_ARG" == "" ]; then
    return
  fi
  if [ "$CB_HOST_ARG" == "" ]; then
    return
  fi
  SLURM_TEMP=/tmp/slurm.$$
  pdsh -t 1 -w $CB_LOGIN,$CB_HEAD ps -el >& $SLURM_TEMP
  cat $SLURM_TEMP | sort -u | grep opensm  >  $SLURM_OUT 2>&1
  SUB1=`cat  $SLURM_OUT | awk -F':' '{print $1}' | sort -u | awk '{printf "%s%s", $1," " }'`
  if [ "$SUB1" == "" ]; then
    echo "   $CB_HEAD,$CB_LOGIN: ***error: opensm not running on any host"
    echo "      Fix: sudo ssh $CB_HEAD service opensm start   "
    echo "      Fix: sudo ssh $CB_LOGIN service opensm start   "
  else
    SLURMCOUNT=`cat  $SLURM_OUT | awk -F':' '{print $1}' | sort -u | wc -l`
    echo "   $CB_HEAD,$CB_LOGIN: opensm on $SLURMCOUNT hosts"
  fi
  rm -f $SLURM_TEMP
}

#---------------------------------------------
#                   IBSPEED
#---------------------------------------------

IBSPEED ()
{
  local CB_HOST_ARG=$1
 
  if [ "$CB_HOST_ARG" == "" ]; then
    return
  fi
  local CURDIR=`pwd`
  IBTEMP=/tmp/ibnet.$$
  pdsh -t 1 -w $CB_HOST_ARG $CURDIR/ibspeed.sh >& $IBTEMP 
  cat $IBTEMP | grep -v ssh | grep -v Connection | sort >& $IBRATE
  RATE0=`head -1 $IBRATE | awk '{print $2}'`
  if [ $RATE0 -eq 0 ]; then
    return
  fi
  RATEBAD=
  WARNING=
  while read line 
  do
    host=`echo $line | awk '{print $1}' | awk -F':' '{print $1}'`
    RATEI=`echo $line | awk '{print $2}'`
    if [ "$RATEI" != "$RATE0" ]; then
      if [ $RATEI -lt $RATE0 ]; then
        WARNING="***warning: "
      fi
      if [ "$RATEI" != "Connection" ]; then
        if [ "$RATEBAD" == "" ]; then
          RATEBAD="$host/$RATEI"
        else
          RATEBAD="$RATEBAD $host/$RATEI"
        fi
      fi
    fi
  done < $IBRATE

  if [ "$RATEBAD" == "" ]; then
    echo "   ${CB_HOST_ARG}-ib: IB data rate $RATE0 Gb/s"
  else
    echo "   ${CB_HOST_ARG}-ib: ${WARNING}IB data rate $RATE0 Gb/s except on $RATEBAD"
  fi
  rm -f $IBTEMP
}

#---------------------------------------------
#                   RUN_CLUSTER_CHECK
#---------------------------------------------

RUN_CLUSTER_CHECK ()
{
  local LOG=$1
  local CB_HOST_ARG=$2

  if [ "$CB_HOST_ARG" != "" ]; then
    NODEFILE=$OUTPUT_DIR/$LOG.hosts
    WARNINGFILE=$OUTPUT_DIR/${LOG}_execution_warnings.log
    OUTFILE=$OUTPUT_DIR/${LOG}.out
    RESULTSFILE=$OUTPUT_DIR/${LOG}_results.out
    pdsh -t 1 -w $CB_HOST_ARG date   >& $CLUSTEROUT
    sort $CLUSTEROUT | grep -v ssh | grep -v Connection | awk '{print $1 }' | awk -F':' '{print $1}' > $NODEFILE
    nup=`wc -l $NODEFILE`
    if [ "$nup" == "0" ]; then
      echo "   $CB_HOST_ARG: ***error: all hosts are down - cluster checker not run"
    else
      echo "   $CB_HOST_ARG: results in `basename $RESULTSFILE` and `basename $WARNINGFILE`"
      $CHECK_CLUSTER -l error -f $NODEFILE -o $RESULTSFILE >& $OUTFILE
      if [ -e clck_execution_warnings.log ]; then
        mv clck_execution_warnings.log $WARNINGFILE
      fi
    fi
  fi
}

#---------------------------------------------
#                   PROVISION_DATE_CHECK
#---------------------------------------------

PROVISION_DATE_CHECK ()
{
  local CB_HOSTETH_ARG=$1

  if [ "$CB_HOSTETH_ARG" == "" ]; then
    return 0
  fi
  PROVTEMP=/tmp/prov.$$
  pdsh -t 1 -w $CB_HOSTETH_ARG `pwd`/getrevdate.sh >& $PROVTEMP
  cat $PROVTEMP |  grep -v ssh | grep -v Connection | sort >  $FSOUT 2>&1

  NF0=`head -1 $FSOUT | awk '{print $2}'`
  FSDOWN=
  while read line 
  do
    host=`echo $line | awk '{print $1}'`
    host=`echo $host | sed 's/.$//'`
    NFI=`echo $line | awk '{print $2}'`
    if [ "$NFI" != "$NF0" ]; then
      if [ "$FSDOWN" == "" ]; then
        FSDOWN="$host/$NFI"
      else
        FSDOWN="$FSDOWN $host/$NFI"
      fi
    fi
  done < $FSOUT

  if [ "$FSDOWN" == "" ]; then
    echo "   $CB_HOSTETH_ARG: imaged on $NF0"
  else
    echo "   $CB_HOSTETH_ARG: imaged on $NF0 except for $FSDOWN"
  fi
  rm -f $PROVTEMP
}

#---------------------------------------------
#                   CORE_CHECK
#---------------------------------------------

CORE_CHECK ()
{
  local CB_HOSTETH_ARG=$1

  if [ "$CB_HOSTETH_ARG" == "" ]; then
    return 0
  fi
  CORETEMP=/tmp/core.$$
  pdsh -t 1 -w $CB_HOSTETH_ARG "grep processor /proc/cpuinfo | wc -l" >& $CORETEMP
  cat $CORETEMP | grep -v ssh | grep -v Connection | sort >  $FSOUT 2>&1

  NF0=`head -1 $FSOUT | awk '{print $2}'`
  FSDOWN=
  while read line 
  do
    host=`echo $line | awk '{print $1}'`
    host=`echo $host | sed 's/.$//'`
    NFI=`echo $line | awk '{print $2}'`
    if [ "$NFI" != "$NF0" ]; then
      if [ "$FSDOWN" == "" ]; then
        FSDOWN="$host/$NFI"
      else
        FSDOWN="$FSDOWN $host/$NFI"
      fi
    fi
  done < $FSOUT

  if [ "$FSDOWN" == "" ]; then
    echo "   $CB_HOSTETH_ARG: $NF0 CPU cores"
  else
    echo "   $CB_HOSTETH_ARG: ***warning: $NF0 CPU cores except $FSDOWN"
    echo "      Fix: boot into BIOS and disable hyperthreading"
  fi
  rm -f $CORETEMP
}

#---------------------------------------------
#                   MEM_DIFF
#---------------------------------------------

MEM_DIFF ()
{
  MEM1=$1
  MEM2=$2
  MIN_MEM=$3

  if [ "$MEM1" == "$MEM2" ]; then
    return 0
  fi
  if [ "$MIN_MEM" != "" ]; then
    if [ $MEM2 -gt $MIN_MEM ]; then
      return 0
    fi
  fi
  DIFF=`echo $((MEM1 - MEM2))`
  if [ "$DIFF" == "1"  ]; then
    return 0
  fi
  DIFF=`echo $((MEM2 - MEM1))`
  if [ "$DIFF" == "1"  ]; then
    return 0
  fi
  return 1
}

#---------------------------------------------
#                   MEMORY_CHECK
#---------------------------------------------

MEMORY_CHECK ()
{
  local outdir=$1
  local CB_HOST_ARG=$2
  local MIN_MEM=$3

  if [ "$CB_HOST_ARG" == "" ]; then
    return 0
  fi
  MEMORY_OUT=$outdir/memory.out
  MEMORY_OUT2=$outdir/memory.out2
  pdsh -t 1 -w $CB_HOST_ARG `pwd`/getmem.sh  >& $MEMORY_OUT2
  cat $MEMORY_OUT2 | grep -v ssh | grep -v Connection | sort >& $MEMORY_OUT
  memory0=`head -1 $MEMORY_OUT | awk '{print $2}'`

  local CURDIR=`pwd`
  cd $outdir
 
  MEMORY_DIFF=
  while read line 
  do
    hosti=`echo $line | awk '{print $1}' | awk -F':' '{print $1}'`
    memoryi=`echo $line | awk '{print $2}'`
    MEM_DIFF $memory0 $memoryi $MIN_MEM
    if [ "$?" == "1" ]; then
      if [ "$MEMORY_DIFF" == "" ]; then
        MEMORY_DIFF="$hosti/$memoryi"
      else
        MEMORY_DIFF="$MEMORY_DIFF $hosti/$memoryi"
      fi
    fi
  done < $MEMORY_OUT
  cd $CURDIR

  if [ "$MEMORY_DIFF" == "" ]; then
    echo "   $CB_HOST_ARG: $memory0 MB or greater"
  else
    echo "   $CB_HOST_ARG: ***warning: $memory0 MB or greater except on $MEMORY_DIFF "
  fi
}

#---------------------------------------------
#                   SPEED_CHECK
#---------------------------------------------

SPEED_CHECK ()
{
  local outdir=$1
  local CB_HOST_ARG=$2

  if [ "$CB_HOST_ARG" == "" ]; then
    return 0
  fi
  SPEED_OUT=$outdir/speed.out
  SPEED_OUT2=$outdir/speed.out2
  pdsh -t 1 -w $CB_HOST_ARG `pwd`/getspeed.sh  >& $SPEED_OUT2
  cat $SPEED_OUT2 | grep -v ssh | grep -v Connection | sort >& $SPEED_OUT
  speed0=`head -1 $SPEED_OUT | awk '{print $2}'`

  local CURDIR=`pwd`
  cd $outdir
 
  SPEED_DIFF=
  while read line 
  do
    hosti=`echo $line | awk '{print $1}' | awk -F':' '{print $1}'`
    speedi=`echo $line | awk '{print $2}'`
    if [ "$speed0" != "$speedi" ]; then
      if [ "$SPEED_DIFF" == "" ]; then
        SPEED_DIFF="$hosti/$speedi"
      else
        SPEED_DIFF="$SPEED_DIFF $hosti/$speedi"
      fi
    fi
  done < $SPEED_OUT
  cd $CURDIR

  if [ "$SPEED_DIFF" == "" ]; then
    echo "   $CB_HOST_ARG: clock rate $speed0"
  else
    echo "   $CB_HOST_ARG: clock rate $speed0 except on $SPEED_DIFF"
  fi
}

#---------------------------------------------
#                   IS_IPMI_DOWN
#---------------------------------------------

IS_IPMI_DOWN ()
{
  local ITEM=$1

  IS_DOWN=`ping -c 1 $ITEM |& head -2 | tail -1 | grep Unreachable | wc -l`
  if [ $IS_DOWN -eq 1 ]; then
    return 1
  fi
  return 0
}

#---------------------------------------------
#                   CAN_CONNECT_IPMI
#---------------------------------------------

CAN_CONNECT_IPMI ()
{
  local IPMI_HOST=$1

  if [[ "$IPMI_password" != "" ]] && [[ "$IPMI_username" != "" ]]; then
    IS_DOWN=`ipmitool -I lanplus -U $IPMI_username -P $IPMI_password -H $IPMI_HOST mc info |& head -1 | grep Unable | wc -l`
  else
    IS_DOWN=1
  fi
  if [ $IS_DOWN -eq 0 ]; then
    return 1
  fi
  return 0
}

#---------------------------------------------
#                   IS_HOST_DOWN
#---------------------------------------------

IS_HOST_DOWN ()
{
  local ITEM=$1

  for i in $ETHDOWN ; do
    if [ "$ITEM" == "$i" ]; then
      return 1
    fi
  done
  return 0
}

#---------------------------------------------
#                   GET_CHID
#---------------------------------------------

GET_CHID ()
{
  local base=$1
  local num=$2

  if [ $num -gt 99 ]; then
    CHID=$base$num
  else
    if [ $num -gt 9 ]; then
      CHID=${base}0$num
    else
      CHID=${base}00$num
    fi
  fi
  echo $CHID
}

#---------------------------------------------
#                   HAVE_JOBS_RUNNING
#---------------------------------------------

HAVE_JOBS_RUNNING ()
{
  local PREFIX=$1

  JOBS_REMAINING=`qstat -a | awk '{print $2 $4 $10}' | grep $(whoami) | grep $PREFIX | grep -v 'C$' | wc -l`
  if [ $JOBS_REMAINING -eq 0 ]; then
    return 0;
  fi
  return 1
}

#---------------------------------------------
#                   WAIT_CASES_END
#---------------------------------------------

WAIT_TEST_CASES_END()
{
  local PREFIX=$1
  local REPORT_STATUS=$2

# Scans job queue and waits for cases to end
  while          [[ `qstat -a | awk '{print $2 $4 $10}' | grep $(whoami) | grep $PREFIX | grep -v 'C$'` != '' ]]; do
    JOBS_REMAINING=`qstat -a | awk '{print $2 $4 $10}' | grep $(whoami) | grep $PREFIX | grep -v 'C$' | wc -l`
      if [ $SECONDS -gt $MAXRUNTIME ]; then
         qstat -a  | grep $(whoami) | grep $JOBPREFIX |  awk '{ system("scancel  " $1)}'
         break
      fi
    if [ "$REPORT_STATUS" == "1" ]; then
      echo "Waiting for $JOBS_REMAINING test cases to complete."
    fi
    sleep 30
  done
}

#---------------------------------------------
#                   RUN_TEST_CASES
#---------------------------------------------

RUN_TEST_CASES ()
{
  local PREFIX=$1
  local QUEUE=$2

  local CURDIR=`pwd`

  if [ "$QUEUE" == "" ]; then
    return
  fi

# make sure we can find qfds.sh 
  QFDS=
  QFDSDIR=$FIREMODELS_ROOT/fds/Utilities/Scripts
  if [ -d $QFDSDIR ]; then
    cd $QFDSDIR
    QFDS=`pwd`/qfds.sh
    if [ ! -e $QFDS ]; then
      QFDS=
    fi
    cd $CURDIR
  fi
  if [ "$QFDS" == "" ]; then
    echo "***error: qfds.sh not found, test cases not run"
    return 1
  fi
  if [ ! -e $FIREMODELS_ROOT/fds/Build/impi_intel_linux/fds_impi_intel_linux ]; then
     echo "***error: fds executable not found.  Was expecting it at:"
     echo "          $FIREMODELS_ROOT/fds/Build/impi_intel_linux/fds_impi_intel_linux ,"
     echo "          test cases not run."
     return 1
  fi
  
  cd $FDSOUTPUT_DIR
  for i in `seq 1 $NCASES_PER_QUEUE`; do
    CHID=`GET_CHID ${QUEUE}_ $i`
    ../makecase.sh $CHID $FDSOUTPUT_DIR
    $QFDS -p 24 -j $PREFIX -q $QUEUE $CHID.fds >& /dev/null
  done
  echo "   $NCASES_PER_QUEUE cases submitted to $QUEUE"
  cd $CURDIR
}

#---------------------------------------------
#                   CHECK_FDS_OUT
#---------------------------------------------

CHECK_FDS_OUT ()
{
  local PREFIX=$1
  local QUEUE=$2

  if [ "$QUEUE" == "" ]; then
    return
  fi

  local CURDIR=`pwd`

  cd $FDSOUTPUT_DIR
  FAIL=0
  for i in `seq 1 $NCASES_PER_QUEUE`; do
    CHID=`GET_CHID ${QUEUE}_ $i`
    OUTFILE=$CHID.out
    if [ -e $OUTFILE ]; then
      CHECK=`tail -10 $OUTFILE | grep successfully | wc -l`
    else
      CHECK=0
    fi
    if [ $CHECK -eq 0 ]; then
      FAIL=$((FAIL+1))
    fi
  done
  if [ $FAIL -eq 0 ]; then
    echo "   $QUEUE:   all $NCASES_PER_QUEUE cases succeeded"
  else
    echo "   $QUEUE: ***error: $FAIL/$NCASES_PER_QUEUE cases failed"
  fi
  cd $CURDIR
}

#---------------------------------------------
#                   CHECK_TEST_CASES
#---------------------------------------------

CHECK_TEST_CASES ()
{
  local REPORT_STATUS=$1
  echo ""
  echo "----- FDS case check ----------"
  WAIT_TEST_CASES_END $JOBPREFIX $REPORT_STATUS
  if [ "$TEST_QUEUE" == "each" ]; then
    CHECK_FDS_OUT $JOBPREFIX $CB_QUEUE1
    CHECK_FDS_OUT $JOBPREFIX $CB_QUEUE2
    CHECK_FDS_OUT $JOBPREFIX $CB_QUEUE3
    CHECK_FDS_OUT $JOBPREFIX $CB_QUEUE4
    CHECK_FDS_OUT $JOBPREFIX $CB_QUEUE5
  else
    CHECK_FDS_OUT $JOBPREFIX $TEST_QUEUE
  fi
}

#---------------------------------------------
#                   SETUP_QUEUES
#---------------------------------------------

SETUP_QUEUES () {
  TEST_QUEUE=$1
  if [ "$TEST_QUEUE" == "each" ]; then
    if [ "$HAVE_CB_QUEUES" == "" ]; then
      echo "***error: environment variables CB_QUEUE1, CB_QUEUE2, "
      echo "          CB_QUEUE3, CB_QUEUE4 and/or CB_QUEUE5 not defined"
      echo "          use a different queue name"
      exit
    fi
  else
    sinfo | awk 'NR > 1 { print $1 }' | awk -F'*' '{print $1}' | sort -u > /tmp/queues.$$
    have_queue=`grep -w $TEST_QUEUE /tmp/queues.$$ | wc -l`
    rm /tmp/queues.$$
    if [ $have_queue -eq 0 ]; then
      echo "***error: $TEST_QUEUE is an invalid queue"
      exit
     fi
  fi
}

#************************** beginning of script ******************************************

#*** find platform script is running on

platform="linux"
if [ "`uname`" == "Darwin" ] ; then
  platform="osx"
fi

#*** find user running script

WHOAMI=`whoami`
if [ "$WHOAMI" == "root" ]; then
  echo "***error: this script cannot be run as root"
  exit
fi

JOBPREFIX=CB_
SCRIPTDIR=`pwd`
BIN=`dirname "$0"`
if [ "$BIN" == "." ]; then
  BIN=
fi
SCRIPTDIR=$SCRIPTDIR/$BIN

TEST_QUEUE=
HAVE_CB_QUEUES=
if [ "$CB_QUEUE1" != "" ]; then
  HAVE_CB_QUEUES=1
fi
if [ "$CB_QUEUE2" != "" ]; then
  HAVE_CB_QUEUES=1
fi
if [ "$CB_QUEUE3" != "" ]; then
  HAVE_CB_QUEUES=1
fi
if [ "$CB_QUEUE4" != "" ]; then
  HAVE_CB_QUEUES=1
fi
if [ "$CB_QUEUE5" != "" ]; then
  HAVE_CB_QUEUES=1
fi

NCASES_PER_QUEUE=20
FORCE_UNLOCK=
ONLY_RUN_TEST_CASES=
PASSWORD_GIVEN=
USE_SUDO=
IPMI_password=
IPMI_username=
UPDATE_ARCHIVE=
USE_INTEL_CLUSTER_CHECKER=
ONLY_NETWORK_CHECKS=
QUEUE=
MAXRUNTIME=600

while getopts 'Cfhn:NP:q:Q:uU:' OPTION
do
case $OPTION  in
  C)
   USE_INTEL_CLUSTER_CHECKER=1
   ;;
  f)
   FORCE_UNLOCK=1
   ;;
  h)
   ./clusterbot_usage.sh clusterbot.sh $NCASES_PER_QUEUE 0
   exit
   ;;
  N)
   ONLY_NETWORK_CHECKS=1
   ;;
  n)
   NCASES="$OPTARG"
   re='^[0-9]+$'
   if ! [[ $NCASES =~ $re ]] ; then
     echo "***error: -n $NCASES not a number"
     exit
   fi 
   NCASES_PER_QUEUE=$NCASES
   ;;
  P)
   IPMI_password=$OPTARG
   ;;
  Q)
   ONLY_RUN_TEST_CASES=1
   QUEUE=$OPTARG
   ;;
  q)
   QUEUE=$OPTARG
   ;;
  u)
   UPDATE_ARCHIVE="1"
   ;;
  U)
   IPMI_username=$OPTARG
   ;;
esac
done
shift $(($OPTIND-1))

if [ "$ONLY_NETWORK_CHECKS" == "1" ]; then
   ONLY_RUN_TEST_CASES=
   QUEUE=
fi

if [ "$QUEUE" != "" ]; then
   SETUP_QUEUES $QUEUE
fi

# --------------------- make sure output directories exist  --------------------

MAKE_DATA_DIRS ||  exit

# --------------------- define file names --------------------

ETHOUT=$FILES_DIR/ethout.$$
CLUSTEROUT=$FILES_DIR/clusterout.$$
ETHUP=$FILES_DIR/ethup.33
CHECKEROUT=$FILES_DIR/checkerout.$$
FSOUT=$FILES_DIR/fsout.$$
MOUNTOUT=$FILES_DIR/mountout.$$
IBOUT=$FILES_DIR/ibout.$$
SLURM_OUT=$FILES_DIR/slurm_out.$$
IBRATE=$FILES_DIR/ibrate.$$
SLURMRPM_OUT=$FILES_DIR/slurmrpmout.$$
DOWN_HOSTS=$FILES_DIR/downhosts.$$
UP_HOSTS=$FILES_DIR/uphosts.$$
LOCK_FILE=$HOME/.clusterbot/lockfile

MKDIR $HOME/.clusterbot

ARCHIVEDIR=$HOME/.clusterbot/archive
MKDIR $ARCHIVEDIR

if [[ "$FORCE_UNLOCK" == "" ]] && [[ -e $LOCK_FILE ]]; then
  echo "***error: another instance of clusterbot.sh is running"
  echo "          If this is not the case, rerun using the -f option"
  exit
fi

touch $LOCK_FILE

# --------------------- setup Intel cluster checker  --------------------

if [ "$USE_INTEL_CLUSTER_CHECKER" != "" ]; then
  SETUP_CLCK
fi

# --------------------- initial error checking --------------------

ERROR=

#*** only do these error checks on linux computers
if [ "$platform" == "linux" ]; then
  if [ "$CB_HOSTS" == "" ]; then
    ERROR=1
    echo "***error: environment variable CB_HOSTS not defined"
  fi
  if [ "$CB_HOST1" != "" ]; then
    if [ "$CB_HOSTIB1" == "" ]; then
     ERROR=1
      echo "***error: CB_HOSTIB1 must be defined if CB_HOST1 is defined"
    fi
  fi
  if [ "$CB_HOST2" != "" ]; then
    if [ "$CB_HOSTIB2" == "" ]; then
      ERROR=1
      echo "***error: CB_HOSTIB2 must be defined if CB_HOST2 is defined"
    fi
  fi
  if [ "$CB_HOST3" != "" ]; then
    if [ "$CB_HOSTIB3" == "" ]; then
      ERROR=1
      echo "***error: CB_HOSTIB3 must be defined if CB_HOST3 is defined"
    fi
  fi
  if [ "$CB_HOST4" != "" ]; then
    if [ "$CB_HOSTIB4" == "" ]; then
      ERROR=1
      echo "***error: CB_HOSTIB4 must be defined if CB_HOST4 is defined"
    fi
  fi
  if [ "$ERROR" == "1" ]; then
    exit
  fi
fi

# --------------------- run fds test cases --------------------
# (check that they finished ok at the end of the script)

if [ "$ONLY_RUN_TEST_CASES" != "1" ]; then
  echo "------ $CB_HOSTS status ----------"
  TEMP_RUN=/tmp/run.$$
  git describe --dirty --long >& $TEMP_RUN
  not_have_git=`cat $TEMP_RUN | grep fatal | wc -l`
  if [ $not_have_git -eq 0 ]; then
    echo "------ `git describe --dirty --long` ----------"
  fi
  rm -f $TEMP_RUN
fi
if [ "$TEST_QUEUE" != "" ]; then
  echo ""
  echo "----- submitting test cases ------------"
  HAVE_JOBS_RUNNING $JOBPREFIX
  if [ "$?" == "1" ]; then
    echo "***error: clusterbot cases are still running"
    echo "          kill these cases or start clusterbot again WITHOUT the -q option"
    exit
  fi
  if [ "$TEST_QUEUE" == "each" ]; then
    RUN_TEST_CASES $JOBPREFIX $CB_QUEUE1
    RUN_TEST_CASES $JOBPREFIX $CB_QUEUE2
    RUN_TEST_CASES $JOBPREFIX $CB_QUEUE3
    RUN_TEST_CASES $JOBPREFIX $CB_QUEUE4
    RUN_TEST_CASES $JOBPREFIX $CB_QUEUE5
  else
    RUN_TEST_CASES $JOBPREFIX $TEST_QUEUE
  fi
fi
if [ "$ONLY_RUN_TEST_CASES" == "1" ]; then
  CHECK_TEST_CASES $ONLY_RUN_TEST_CASES

  rm $LOCK_FILE
  exit
fi

if [ "$platform" == "osx" ]; then
  exit
fi

echo ""
echo "----- network checks ------------"
# --------------------- check ethernet --------------------

pdsh -t 1 -w "$ALL_HOSTS" date   >& $ETHOUT
ETHDOWN=`sort $ETHOUT | grep -E 'timed|refused|route' | awk -F':' '{print $1}' | awk '{printf "%s ", $1}'`
ETHUP=`sort $ETHOUT | grep -v -E 'timed|refused|route' | awk -F':' '{print $1}' | awk '{printf "%s ", $1}'`

ETH_ALL_UP=
if [ "$ETHDOWN" == "" ]; then
  echo "   $ALL_HOSTS: ethernet up"
  ETH_ALL_UP=1
else
  echo "   $ALL_HOSTS: ***warning: ethernet down on $ETHDOWN"
fi

# --------------------- check infiniband --------------------

rm -rf $IBOUT
touch $IBOUT
if [[ "$CB_HOST1" != "" ]] && [[ $CB_HOSTIB1 != "" ]]; then
  ssh $CB_HOST1 pdsh -t 1 -w $CB_HOSTIB1 date  >>  $IBOUT 2>&1
fi
if [[ "$CB_HOST2" != "" ]] && [[ $CB_HOSTIB2 != "" ]]; then
  ssh $CB_HOST2 pdsh -t 1 -w $CB_HOSTIB2 date  >>  $IBOUT 2>&1
fi
if [[ "$CB_HOST3" != "" ]] && [[ $CB_HOSTIB3 != "" ]]; then
  ssh $CB_HOST3 pdsh -t 1 -w $CB_HOSTIB3 date  >>  $IBOUT 2>&1
fi
if [[ "$CB_HOST4" != "" ]] && [[ $CB_HOSTIB4 != "" ]]; then
  ssh $CB_HOST4 pdsh -t 1 -w $CB_HOSTIB4 date  >>  $IBOUT 2>&1
fi
IBDOWN_HOSTS=`grep -E 'timed|refused|route'  $IBOUT | grep out | sort | awk -F':' '{print $1}' | awk '{printf "%s ", $1}'`

IBDOWN=
for hostib in $IBDOWN_HOSTS; do
#*** only warn if ethernet is up and infiniband is down

  hosteth=`echo $hostib | sed 's/-ib$//'`
  IS_HOST_DOWN $hosteth
  if [ "$?" == "0" ]; then
    if [ "$IBDOWN" == "" ]; then
      IBDOWN="$hostib"
    else
      IBDOWN="$IBDOWN $hostib"
    fi
  fi
done

if [ `cat $IBOUT | wc -l` -ne 0 ]; then
  if [ "$IBDOWN" == "" ]; then
    if [ "$ETH_ALL_UP" == "1" ]; then
      echo "   $ALL_HOSTS: infiniband up"
    else
      echo "   $ALL_HOSTS: infiniband up on working hosts"
    fi
  else
    echo "   $ALL_HOSTS: ***error: infiniband down on $IBDOWN and nodes with non-working ethernet"
  fi
fi

# --------------------- check ipmi --------------------

if [[ "$IPMI_username" != "" ]] && [[ "$IPMI_password" != "" ]]; then
  IPMIDOWN=
  IPMIEXT=-ipmi
  for hosteth in $IPMIUP; do
    hostipmi=${hosteth}$IPMIEXT
    CAN_CONNECT_IPMI $hostipmi
    if [ "$?" == "0" ]; then
      if [ "$IPMIDOWN" == "" ]; then
        IPMIDOWN="$hosteth"
      else
        IPMIDOWN="$IPMIDOWN $hosteth"
      fi
    fi
  done
  if [ "$IPMIDOWN" == "" ]; then
    echo "   $CB_HOSTS: ipmi accessible"
  else
    echo "   $CB_HOSTS: ***warning: ipmi/bmc interface inaccessible on $IPMIDOWN"
  fi
fi

OPENSM_CHECK $CB_HOST1 $CB_HOSTIB1
OPENSM_CHECK $CB_HOST2 $CB_HOSTIB2
OPENSM_CHECK $CB_HOST3 $CB_HOSTIB3
OPENSM_CHECK $CB_HOST4 $CB_HOSTIB4

if [ "$ONLY_NETWORK_CHECKS" != "" ]; then
  echo ""
  echo "----- clusterbot complete --------------"

  rm $LOCK_FILE
  exit
fi

# --------------------- infiniband speed check --------------------

IBSPEED $CB_HOSTETH1
IBSPEED $CB_HOSTETH2
IBSPEED $CB_HOSTETH3
IBSPEED $CB_HOSTETH4

echo ""
echo "----- OS checks -----------------"

CHECK_FILE /etc/redhat-release error 0 $FILES_DIR "$ALL_HOSTS"

# --------------------- rpm check --------------------
RPM_CHECK 0 ALL $CB_HOSTS

# --------------------- check provisioning date --------------------
PROVISION_DATE_CHECK $CB_HOSTETH1
PROVISION_DATE_CHECK $CB_HOSTETH2
PROVISION_DATE_CHECK $CB_HOSTETH3
PROVISION_DATE_CHECK $CB_HOSTETH4

# --------------------- check number of cores --------------------

echo ""
echo "----- CPU checks ----------------"
CORE_CHECK $CB_HOSTETH1
CORE_CHECK $CB_HOSTETH2
CORE_CHECK $CB_HOSTETH3
CORE_CHECK $CB_HOSTETH4

SPEED_CHECK $FILES_DIR $CB_HOSTETH1
SPEED_CHECK $FILES_DIR $CB_HOSTETH2
SPEED_CHECK $FILES_DIR $CB_HOSTETH3
SPEED_CHECK $FILES_DIR $CB_HOSTETH4

echo ""
echo "----- memory check -------------"

MEMORY_CHECK $FILES_DIR $CB_HOSTETH1 $CB_MEM1
MEMORY_CHECK $FILES_DIR $CB_HOSTETH2 $CB_MEM2
MEMORY_CHECK $FILES_DIR $CB_HOSTETH3 $CB_MEM3
MEMORY_CHECK $FILES_DIR $CB_HOSTETH4 $CB_MEM4

echo ""
echo "----- clock checks --------------"

CHECK_DAEMON chronyd error "$ALL_HOSTS"

CHECK_FILE /etc/chrony.conf error 0 $FILES_DIR "$CB_HOSTS $CB_LOGIN"

TOLERANCE=0.00002
TIME_CHECK 0 $TOLERANCE $FILES_DIR "$CB_HOSTS" 
TIME_CHECK 0 $TOLERANCE $FILES_DIR "$CB_LOGIN $CB_HEAD" 

echo ""
echo "----- file system checks -------"

#*** check  NFS cross mounts

MOUNT_CHECK 0 $FILES_DIR $CB_HOSTS

#*** check /etc/exports file

CHECK_FILE /etc/exports error 0 $FILES_DIR $CB_HOSTS

#*** check /etc/fstab file

FSTAB_CHECK $FILES_DIR 0 $CB_HOSTS

echo ""
echo "----- login/host checks --------"
ACCT_CHECK /etc/group  $FILES_DIR "$ALL_HOSTS"
ACCT_CHECK /etc/passwd $FILES_DIR "$ALL_HOSTS"
HOST_CHECK $FILES_DIR 0 "$ALL_HOSTS"

echo ""
echo "----- ssh configuration checks ---"

CHECK_FILE_DATE /etc/ssh/sshd_config
CHECK_DIR_LIST  /etc ssh

echo ""
echo "----- slurm checks --------------"

#*** check that slurm is online
pbsnodes -l | awk '{print $1}' | sort -u  > $DOWN_HOSTS
SLURM_DOWN=
while read line 
do
  host=`echo $line | awk '{print $1}'`

  IS_HOST_DOWN $host
# only care if slurm is down on a host that is up
  if [ "$?" == "0" ]; then
    if [ "$SLURM_DOWN" == "" ]; then
      SLURM_DOWN="$host"
    else
      SLURM_DOWN="$SLURM_DOWN $host"
    fi
  fi
done < $DOWN_HOSTS

if [ "$SLURM_DOWN" == "" ]; then
  echo "   $CB_HOSTS: slurm online"
else
  echo "   $CB_HOSTS: ***warning: slurm offline on $SLURM_DOWN"
  echo "      Fix: sudo scontrol update nodename=HOST state=resume"
  echo "      This fix can only be applied to a HOST that is up and with"
  echo "      a working ethernet and infiniband network connection."
fi

#*** check slurm configuration file --------------------

CHECK_FILE /etc/slurm/slurm.conf error 0 $FILES_DIR $CB_HOSTS

#*** check slurm daemon

CHECK_DAEMON slurmd error $CB_HOSTS

#*** ganglia checks -----------------------------

GANGLIA=`ps -el | grep gmetad`
if [ "$GANGLIA" != "" ]; then
  echo ""
  echo "----- ganglia checks ------------"
  CHECK_FILE /etc/ganglia/gmond.conf warning 0 $FILES_DIR $CB_HOSTS
  CHECK_DAEMON gmond warning $CB_HOSTS
fi

# --------------------- run cluster checker --------------------

if [ "$CHECK_CLUSTER" != "" ]; then
  echo ""
  echo "----- Intel Cluster Checker -------------"
  RUN_CLUSTER_CHECK ETH1 $CB_HOSTETH1
  RUN_CLUSTER_CHECK ETH2 $CB_HOSTETH2
  RUN_CLUSTER_CHECK ETH3 $CB_HOSTETH3
  RUN_CLUSTER_CHECK ETH4 $CB_HOSTETH4
fi

if [[ "$ONLY_RUN_TEST_CASES" != "1" ]] && [[ "$TEST_QUEUE" != "" ]]; then
  CHECK_TEST_CASES 0
fi

echo ""
echo "----- clusterbot complete --------------"

rm $LOCK_FILE
